# 3. 分红包

将m元钱随机分成n个红包，要求每个红包中的钱数都是正整数。每次输出一种可行结果即可。

**Example:**

输入只有一行，两个正整数m n

输出一行，包含n个正整数，其和为m

```
100 10

```

## Solution 1: Brute force

### Idea: 

首先每个红包中都是正整数，也就是说每个红包中至少要有一块钱，常用的插板法可以满足我们的要求。将m元钱视为m个小球，接着生成n-1个范围在1到m-1之间的不重复的随机数，然后依次求出两个隔板之间的小球数即可。随机数可以借助set来保存，既能保证不重复又能够自动排序。

这种方法比较直观，但存在一个严重的问题，就是在n接近m的时候，最后随机数生成成功的概率会越来越低，当`n==m`时，我们不得不对`1~m-1`之间的每个数都生成一次，与普通的洗牌算法类似，这将带来严重的资源浪费。所以这个解法并不优秀，甚至可以说是错误的。

另外一种思路是，每次划分红包，我们只需要保证划分之后的`m>=n`即可，因此对于某次划分，假设我们现在还有j元钱和i个没有划分好的红包，则这次红包中的钱数可以是`1~j-i+1`，特殊情况当`j==i`时，我们只能划出1块钱装入这次的红包中。最后要注意的就是，最后一个红包是特例，要将所有剩余的钱都装入这个红包。

### Code: 

```c++
#include <iostream>
#include <stdlib.h>
#include <time.h>

using namespace std;

int main()
{
    int m, n;
    cin>>m>>n;
    if(m<n) return -1;
    srand(time(0));
    for(int i=n; i>=2; --i)
    {
        int money = (rand() %(m-i+1))+1;
        m -= money;
        cout<<money<<' ';
    }

    cout<<m<<endl;
    return 0;
}
```

### Complexity Analysis: 

- Time complexity : $O(n)$. 
- Space complexity : $O(1)$. 

### Rethinking:
这种方法很容易出现的一个问题就是，靠后的红包中的钱数大概率会变得很少，但理论上算法是正确的，且随机数一定只生成n-1次。