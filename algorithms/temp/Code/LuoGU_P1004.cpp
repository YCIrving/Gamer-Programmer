/*
此题刚开始看时以为只是简单的动态规划，但是跟同学讨论之后发现自己的想法是错误的，根本没那么简单
没办法，自己想太难了，看了题解才知道要用一种叫“双线程动态规划”的方法，就是两条线路一起考虑。
说得容易，但是具体理解和实现上却很困难。
程序首先需要保证正确地读入数据，这里又需要考虑坐标的转化，其实如果仔细考虑，本体具有很高的对称
性，所以就不涉及坐标的转化问题，直接拿来用做数组下标就行了。
再一个就是算法的核心思想，有了之前1002的经验，对动态规划有了初步的了解，首先初始化，然后遍历，
遍历时用状态转换方程进行赋值，最后输出。所以程序虽然看着复杂，但是也是有据可循的。
最后一个就是程序的优化，如何轻易地推广到n次是一个问题，显然，动态规划不是很适合，据说可以用流量
来计算，不过现在还不会。另外就是，可以不申请四维数组，只申请三维就行了，当然，另一维表示的含义也就变了。
最后就是对称问题，是不是两条路存在对称的情况，如果可以优化就能减少一半的计算，值得后期慢慢发掘。
*/
#include<iostream>
using namespace std;
int max2(int a,int b)
{
    return a>b?a:b;
}
int max4(int a,int b,int c,int d)
{
    return max2(max2(a,b),max2(c,d));
}
int main()
{
    int map[10][10]={0};
    int price[10][10][10][10]={0};
    int n,a,b,c;
    cin>>n;
    cin>>a>>b>>c;
    while(a!=0&&b!=0)
    {
        map[a][b]=c;
        cin>>a>>b>>c;
    }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            for(int k=1;k<=n;k++)
                for(int l=1;l<=n;l++)
                {
                    //if(i-1>=0&&j-1>=0&&k-1>=0&&l-1>=0)
                   // {
                        price[i][j][k][l]=max4(price[i-1][j][k-1][l],price[i-1][j][k][l-1],price[i][j-1][k-1][l],price[i][j-1][k][l-1])+map[i][j]+map[k][l];
                        if(i==k&&j==l)
                            price[i][j][k][l]-=map[i][j];
                    //}
                }
    cout<<price[n][n][n][n]<<endl;
//    //输出测试
//    for(int i=1;i<=n;i++)
//        {
//            for(int j=1;j<=n;j++)
//        cout<<map[i][j]<<' ';
//        cout<<endl;
//        }
//    //测试结束
    return 0;
}

