### [102\. Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/)

Difficulty: **Medium**

Tags: **Tree**, **Breadth-first Search**

Given a binary tree, return the _level order_ traversal of its nodes' values. (ie, from left to right, level by level).

For example:  
Given binary tree `[3,9,20,null,null,15,7]`,  

```
    3
   / \
  9  20
    /  \
   15   7
```

return its level order traversal as:  

```
[
  [3],
  [9,20],
  [15,7]
]
```

## Solution 1: Recursive

### Idea: 
使用DFS中先序遍历的思想对树进行遍历，同时加入了level的属性，用来将遍历结果按层进行分组。

### Code: 

```c++
class Solution {
public:
    void levelOrderTraversalRecursive(TreeNode* root, int level, vector<vector<int>> &ret)
    {
        if(!root) return;
        // *M* 注意level和size之间的关系
        // *M* 入栈时可以直接压入一个"{}"来达到空vector的目的
        if(ret.size()<level+1) ret.push_back({});
        // 整个过程就是先序遍历的递归形式
        ret[level].push_back(root->val);
        levelOrderTraversalRecursive(root->left, level+1, ret);
        levelOrderTraversalRecursive(root->right, level+1, ret);
    }
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> ret;
        levelOrderTraversalRecursive(root, 0, ret);
        return ret;
    }
};
```

### Complexity Analysis: 

- Time complexity : $O(n)$，因为每个节点恰好会被运算一次。
- Space complexity : $O(n)$，保存输出结果的数组包含 N 个节点的值。

### Details:

> Runtime: 8 ms, faster than 87.11% of C++ online submissions.
>
> Memory Usage: 14.5 MB, less than 19.66% of C++ online submissions.

### Rethinking:
先序遍历和层次遍历之间存在一种有趣的转化，如果我们有了节点的层数，则可以使用先序遍历的方法生成层次遍历的结果。但该方法不能用于简单层次遍历，除非将结果再进行一次整理后再输出。

## Solution 2: Iterative using two queues

### Idea: 
由于简单层次遍历的非递归形式使用了一个队列，所以我们同样可以使用类似的方式进行遍历，只不过这道题要求按层进行区分，会稍微复杂一些。我们使用两个队列来交替进行入队和出队，这样保证每个队列中的元素来自同一层，就能实现分层遍历了。
### Code: 
```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        if(!root) return {};
        queue<TreeNode*> que1, que2;
        vector<vector<int>> ret;
        TreeNode* cur = root;
        que1.push(cur);
        // *M* 注意循环条件
        while(!que1.empty() || !que2.empty())
        {
            // *M* 新增一层
            ret.push_back({});
            // *M* 将不为空的队列进行出队，然后将其子节点压入另外一个队列即可
            // *M* 需要注意的是下面两个条件是互斥的，每次处理一个队列，所以外层的判断不能省略
            if(!que1.empty())
            {
                while(!que1.empty())
                {
                    cur = que1.front();
                    que1.pop();
                    ret[ret.size()-1].push_back(cur->val);
                    if(cur->left) que2.push(cur->left);
                    if(cur->right) que2.push(cur->right);
                }
            }
            else
            {
                while(!que2.empty())
                {
                    cur = que2.front();
                    que2.pop();
                    ret[ret.size()-1].push_back(cur->val);
                    if(cur->left) que1.push(cur->left);
                    if(cur->right) que1.push(cur->right);
                }
            }

        }
        return ret;
    }
};
```

### Complexity Analysis: 

- Time complexity : $O(n)$. 
- Space complexity : $O(n)$. 

### Details:

> Runtime: 12 ms, faster than 66.71% of C++ online submissions.
>
> Memory Usage: 13.6 MB, less than 89.71% of C++ online submissions.

### Rethinking:
双队列的使用也可以通过一个变量来控制当前选择的队列，只是这样需要将两个队列放入一个vector，通过下标进行索引，结构比较复杂。上面这样比较好理解。